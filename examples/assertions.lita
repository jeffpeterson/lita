/// Truthy and falsy values
assert true
assert !false
assert !nil
assert ""
assert 0

/// Identifiers
let x
let x' = 1
let x₂' = 3

assert x' == 1
assert x₂' == 3

/// Literals
assert 1
assert 0xaf == 175
assert 1, 2
assert 0..9
assert (1, 2)
assert 1.class == Number
assert (1, 2).class == Tuple

/// Functions
fn add(a, b) = a + b
assert add(1, 2) == 3

// Variadic Functions
fn sum(...xs)
	let n = 0
	for let i = 0; i < xs.length; i++
		n += xs.get(i)
	return n

assert sum(1, 2, 3) == 6

/// Natives
assert clock()
assert (3; 4) == 3
assert hash(1) == "0x65497e01"
assert hash(nil) == "0x85dfeebb"

/// Math
let a = 2
let b = 4

assert 2 + 2 == 4
assert a + b == 6
assert 2(3) == 6
// assert 2b == 8

/// Strings
assert "Strings"
assert ('0 + '5) == '05
assert ("hi " + "there") == "hi there"
// assert ("hi " x' "there") == "hi 1 there"
assert 'foo / 'bar == "foo/bar"
assert '/ == "/"
assert '"hi there" == "\"hi there\""
assert '( == "("
assert "" nil == ""
assert nil.string == ""
assert "" 3 == "3"
assert "" 3.5 == "3.5"
assert "hi".hash == "0xd7ea6e9a"
assert "hi there".replace("hi", "hello") == "hello there"
assert "hi there".replace(`\w+`, "x") == "x x"
assert "hi there".replace(`\b(\w)(\w+)`, "\\u$1$2") == "Hi There"

assert "howdy".capitalize == "Howdy"
assert " howdy".capitalize == " Howdy"
assert "Howdy".capitalize == "Howdy"

assert "camel_case".camelize == "camelCase"
assert "CamelCase".underscore == "camel_case"
assert "CamelCase".dasherize == "camel-case"

assert "HeLLO".lowercase == "hello"
assert "hEllo".uppercase == "HELLO"

// Regular Expressions
assert `[a-z]`

/// Inspect
assert "hi".inspect == "\e[32m\"hi\"\e[39m"
assert 3.inspect == "\e[34m3\e[39m"
assert (1, 2).inspect == "(\e[34m1\e[39m, \e[34m2\e[39m)"

fn inc(x) = x + 1

/// Tuples
assert (1, 2) == (1, 2)
assert (2, 3) != (1, 2)
// assert (1, 2).map(3) == (3, 6)
// assert (1, 2).map("") == ("1", "2")
// assert (1, 2).map("n:") == ("n:1", "n:2")
// assert (1, 2) * 4 == (4, 8)
// assert (1, 2) * (3, 4) == (3, 8)
// assert [1, 2].map(inc) == [2, 3]
// assert [1, 2].map(.string) == ['1, '2]

/// Arrays
assert [1, 2, 3]
assert [1, 2].get(1) == 2
assert [1, 2, 3].length == 3
// assert Array(1, 2, 3).length == 3
assert [1, 2] + [3] == [1, 2, 3]
assert [1, 2] << 3 == [1, 2, 3]
// print "" + [1, 2]

/// Instances
class Point(x, y)
	fn magnitude = (x + y)
	fn + (b) = Point(x + b.x, y + b.y)
	fn == (b)
		return x == b.x and y == b.y

let p1 = Point(1, 2)
let p2 = Point(3, 4)

assert p1 + p2 == Point(4, 6)

/// Precedence
assert (assert 1) == 1

assert (3b) == 12
assert (b 3) == 12

/// ?: operator
assert (1 ? 2) == 2
assert (1 ?: 2) == 1
assert (nil ? 2) == nil
assert (nil ?: 2) == 2

let i = 0
let j = 0
for ; i < 10; i++
	assert i == (j++)
assert i == 10
assert j == 10

fn empty_fn()

assert empty_fn() == nil

/// match

assert match 1
	1 -> true
	else false

assert match 2
	1 -> false
	else true

fn num_to_ord(x)
	return match x
		1 -> 'one
		2 -> 'two
		else x.string

assert num_to_ord(1) == 'one
assert num_to_ord(2) == 'two
assert num_to_ord(3) == '3

// Check for tail-call optimization
fn loop(n, count)
	n <= 0 and return count // return is an expression
	return loop(n - 1, count + 1)

assert loop(10000, 0) == 10000

// Check for broken tail-call implementation.
// (Re-using frames for all self-calls, not just tail-calls)
fn fib(n)
	if n < 2: return n
	return fib(n - 2) + fib(n - 1)

assert fib(10) == 55

// class Foo(x)
// 	let x' = x + 1

// let foo = Foo(1)

// assert foo.x == 1
// assert foo.x' == 2
// foo.x = 5
// assert foo.x == 5
// assert foo.x' == 2

write "Assertions passed!\n".green
